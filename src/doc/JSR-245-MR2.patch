Index: build.xml
===================================================================
--- build.xml	(revision 67)
+++ build.xml	(working copy)
@@ -1,5 +1,5 @@
 <project name="juel" default="jars" basedir=".">
-	<property name="version" value="2.1.2" />
+	<property name="version" value="2.1.3-SNAPSHOT" />
 
 	<property file="build.properties" />
 
Index: src/main/java/de/odysseus/el/ExpressionFactoryImpl.java
===================================================================
--- src/main/java/de/odysseus/el/ExpressionFactoryImpl.java	(revision 63)
+++ src/main/java/de/odysseus/el/ExpressionFactoryImpl.java	(working copy)
@@ -182,19 +182,22 @@
 	 * The maximum cache size will be as specified unless overridden by property
 	 * <code>javax.el.cacheSize</code>.
 	 */
+	@SuppressWarnings("deprecation")
 	protected TreeStore createTreeStore(int defaultCacheSize, Properties properties) {
 		// create builder
 		EnumSet<Builder.Feature> features = EnumSet.noneOf(Builder.Feature.class);
 		if (properties != null) {
-			if (Boolean.valueOf(properties.getProperty("javax.el.methodInvocations"))) {
+			if (Boolean.valueOf(properties.getProperty("javax.el.methodInvocations", "false"))) {
 				features.add(Builder.Feature.METHOD_INVOCATIONS);
+			} else if (Boolean.valueOf(properties.getProperty("javax.el.methods", "false"))) {
+				features.add(Builder.Feature.METHODS);
 			}
-			if (Boolean.valueOf(properties.getProperty("javax.el.nullProperties"))) {
+			if (Boolean.valueOf(properties.getProperty("javax.el.varArgs", "false"))) {
+				features.add(Builder.Feature.VARARGS);
+			}
+			if (Boolean.valueOf(properties.getProperty("javax.el.nullProperties", "false"))) {
 				features.add(Builder.Feature.NULL_PROPERTIES);
 			}
-			if (Boolean.valueOf(properties.getProperty("javax.el.varArgs"))) {
-				features.add(Builder.Feature.VARARGS);
-			}
 		}
 		
 		TreeBuilder builder = createTreeBuilder(properties, features.toArray(new Builder.Feature[0]));
Index: src/main/java/de/odysseus/el/TreeValueExpression.java
===================================================================
--- src/main/java/de/odysseus/el/TreeValueExpression.java	(revision 63)
+++ src/main/java/de/odysseus/el/TreeValueExpression.java	(working copy)
@@ -22,6 +22,7 @@
 import javax.el.ELContext;
 import javax.el.ELException;
 import javax.el.FunctionMapper;
+import javax.el.ValueReference;
 import javax.el.VariableMapper;
 
 import de.odysseus.el.misc.LocalMessages;
@@ -153,6 +154,11 @@
 		return node.isLiteralText();
 	}
 
+	@Override
+	public ValueReference getValueReference(ELContext context) {
+		return node.getValueReference(bindings, context);
+	}
+
 	/**
 	 * Answer <code>true</code> if this could be used as an lvalue.
 	 * This is the case for eval expressions consisting of a simple identifier or
@@ -169,7 +175,7 @@
 	public boolean isDeferred() {
 		return deferred;
 	}
-
+	
 	/**
 	 * Expressions are compared using the concept of a <em>structural id</em>:
    * variable and function names are anonymized such that two expressions with
Index: src/main/java/de/odysseus/el/tree/ExpressionNode.java
===================================================================
--- src/main/java/de/odysseus/el/tree/ExpressionNode.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/ExpressionNode.java	(working copy)
@@ -17,6 +17,7 @@
 
 import javax.el.ELContext;
 import javax.el.MethodInfo;
+import javax.el.ValueReference;
 
 /**
  * Expression node interface.
@@ -48,6 +49,14 @@
 	public Object getValue(Bindings bindings, ELContext context, Class<?> expectedType);
 
 	/**
+	 * Get value reference.
+	 * @param bindings
+	 * @param context
+	 * @return value reference
+	 */
+	public ValueReference getValueReference(Bindings bindings, ELContext context);
+
+	/**
 	 * Get the value type accepted in {@link #setValue(Bindings, ELContext, Object)}.
 	 * @param bindings bindings containing variables and functions
 	 * @param context evaluation context
Index: src/main/java/de/odysseus/el/tree/impl/Builder.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/Builder.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/Builder.java	(working copy)
@@ -19,6 +19,7 @@
 import java.util.EnumSet;
 
 import javax.el.ELException;
+import javax.el.ELResolver;
 
 import de.odysseus.el.tree.Bindings;
 import de.odysseus.el.tree.NodePrinter;
@@ -45,9 +46,20 @@
 		 * Method invocations as in <code>${foo.bar(1)}</code> are a <em>JUEL</em> extension.
 		 * The method to be invoked is resolved at evaluation just like properties. That is,
 		 * a specialized resolver will have to be provided at evaluation time.
+		 * 
+		 *  This feature is deprecated as of JUEL 2.1.3 in faviour of {@link #METHODS} and
+		 *  will probably be removed in a future release of JUEL.
 		 */
+		@Deprecated
 		METHOD_INVOCATIONS,
 		/**
+		 * Method invocations as in <code>${foo.bar(1)}</code> as specified in JSR 245
+		 * maintenance release 2.
+		 * The method to be invoked is resolved at evaluation time by calling
+		 * {@link ELResolver#invoke(javax.el.ELContext, Object, Object, Class[], Object[])}.
+		 */
+		METHODS,
+		/**
 		 * For some reason we don't understand, the specification does not allow to resolve
 		 * <code>null</code> property values. E.g. <code>${map[key]}</code> will always
 		 * return <code>null</code> if <code>key</code> evaluates to <code>null</code>.
@@ -131,7 +143,7 @@
 		PrintWriter out = new PrintWriter(System.out);
 		Tree tree = null;
 		try {
-			tree = new Builder(Feature.METHOD_INVOCATIONS).build(args[0]);
+			tree = new Builder(Feature.METHODS).build(args[0]);
 		} catch (TreeBuilderException e) {
 			System.out.println(e.getMessage());
 			System.exit(0);
Index: src/main/java/de/odysseus/el/tree/impl/Parser.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/Parser.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/Parser.java	(working copy)
@@ -181,6 +181,10 @@
 		return new AstBracket(base, property, lvalue, strict);
 	}
 	
+	protected AstBracket createAstBracket(AstNode base, AstNode property, List<AstNode> params) {
+		return new AstBracket(base, property, new AstParameters(params));
+	}
+	
 	protected AstChoice createAstChoice(AstNode question, AstNode yes, AstNode no) {
 		return new AstChoice(question, yes, no);
 	}
@@ -193,6 +197,10 @@
 		return new AstDot(base, property, lvalue);
 	}
 	
+	protected AstDot createAstDot(AstNode base, String property, List<AstNode> params) {
+		return new AstDot(base, property, new AstParameters(params));
+	}
+	
 	protected AstFunction createAstFunction(String name, int index, List<AstNode> args) {
 		return new AstFunction(name, index, args, context.isEnabled(Feature.VARARGS));
 	}
@@ -589,6 +597,7 @@
 	/**
 	 * value := (nonliteral | literal) (&lt;DOT&gt; &lt;IDENTIFIER&gt; | &lt;LBRACK&gt; expr &lt;RBRACK&gt;)*
 	 */
+	@SuppressWarnings("deprecation")
 	protected AstNode value() throws ScanException, ParseException {
 		boolean lvalue = true;
 		AstNode v = nonliteral();
@@ -608,6 +617,10 @@
 						consumeToken();
 						v = createAstMethod(createAstDot(v, name, false), list());
 						consumeToken(RPAREN);
+					} else if (token.getSymbol() == LPAREN && context.isEnabled(METHODS)) {
+						consumeToken();
+						v = createAstDot(v, name, list());
+						consumeToken(RPAREN);
 					} else {
 						v = createAstDot(v, name, lvalue);
 					}
@@ -621,6 +634,10 @@
 						consumeToken();
 						v = createAstMethod(createAstBracket(v, property, false, true), list());
 						consumeToken(RPAREN);
+					} else if (token.getSymbol() == LPAREN && context.isEnabled(METHODS)) {
+						consumeToken();
+						v = createAstBracket(v, property, list());
+						consumeToken(RPAREN);
 					} else {
 						v = createAstBracket(v, property, lvalue, strict);
 					}
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstBracket.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstBracket.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstBracket.java	(working copy)
@@ -28,6 +28,11 @@
 		this.property = property;
 	}
 
+	public AstBracket(AstNode base, AstNode property, AstParameters params) {
+		super(base, params);
+		this.property = property;
+	}
+
 	@Override
 	protected Object getProperty(Bindings bindings, ELContext context) throws ELException {
 		return property.eval(bindings, context);
@@ -44,10 +49,13 @@
 		b.append("[");
 		getChild(1).appendStructure(b, bindings);
 		b.append("]");
+		if (params != null) {
+			params.appendStructure(b, bindings);
+		}
 	}
 
 	public int getCardinality() {
-		return 2;
+		return params == null ? 2 : 3;
 	}
 
 	@Override
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstDot.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstDot.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstDot.java	(working copy)
@@ -28,6 +28,11 @@
 		this.property = property;
 	}
 
+	public AstDot(AstNode base, String property, AstParameters params) {
+		super(base, params);
+		this.property = property;
+	}
+
 	@Override
 	protected String getProperty(Bindings bindings, ELContext context) throws ELException {
 		return property;
@@ -43,9 +48,12 @@
 		getChild(0).appendStructure(b, bindings);
 		b.append(".");
 		b.append(property);
+		if (params != null) {
+			params.appendStructure(b, bindings);
+		}
 	}
 
 	public int getCardinality() {
-		return 1;
+		return params == null ? 1 : 2;
 	}
 }
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstEval.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstEval.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstEval.java	(working copy)
@@ -17,6 +17,7 @@
 
 import javax.el.ELContext;
 import javax.el.MethodInfo;
+import javax.el.ValueReference;
 
 import de.odysseus.el.tree.Bindings;
 
@@ -37,6 +38,10 @@
 		return getChild(0).isLeftValue();
 	}
 
+	public ValueReference getValueReference(Bindings bindings, ELContext context) {
+		return child.getValueReference(bindings, context);
+	}
+	
 	@Override
 	public Object eval(Bindings bindings, ELContext context) {
 		return child.eval(bindings, context);
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstIdentifier.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstIdentifier.java	(revision 66)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstIdentifier.java	(working copy)
@@ -25,6 +25,7 @@
 import javax.el.MethodNotFoundException;
 import javax.el.PropertyNotFoundException;
 import javax.el.ValueExpression;
+import javax.el.ValueReference;
 
 import de.odysseus.el.misc.LocalMessages;
 import de.odysseus.el.tree.Bindings;
@@ -61,6 +62,14 @@
 		return false;
 	}
 
+	public ValueReference getValueReference(Bindings bindings, ELContext context) {
+		ValueExpression expression = bindings.getVariable(index);
+		if (expression != null) {
+			return expression.getValueReference(context);
+		}
+		return new ValueReference(null, name);
+	}
+	
 	@Override 
 	public Object eval(Bindings bindings, ELContext context) {
 		ValueExpression expression = bindings.getVariable(index);
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstParameters.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstParameters.java	(revision 0)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstParameters.java	(revision 0)
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2006, 2007 Odysseus Software GmbH
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.odysseus.el.tree.impl.ast;
+
+import java.util.List;
+
+import javax.el.ELContext;
+
+import de.odysseus.el.tree.Bindings;
+
+public class AstParameters extends AstRightValue {
+	protected final List<AstNode> nodes;
+	
+	public AstParameters(List<AstNode> nodes) {
+		this.nodes = nodes;
+	}
+
+	@Override
+	public Object[] eval(Bindings bindings, ELContext context) {
+		Object[] result = new Object[nodes.size()];
+		for (int i = 0; i < nodes.size(); i++) {
+			result[i] = nodes.get(i).eval(bindings, context);
+		}		
+		return result;
+	}
+	
+	@Override
+	public String toString() {
+		return "(...)";
+	}	
+
+	@Override 
+	public void appendStructure(StringBuilder b, Bindings bindings) {
+		b.append("(");
+		for (int i = 0; i < nodes.size(); i++) {
+			if (i > 0) {
+				b.append(", ");
+			}
+			nodes.get(i).appendStructure(b, bindings);
+		}
+		b.append(")");
+	}
+
+	public int getCardinality() {
+		return nodes.size();
+	}
+
+	public AstNode getChild(int i) {
+		return nodes.get(i);
+	}
+}
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstProperty.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstProperty.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstProperty.java	(working copy)
@@ -23,6 +23,7 @@
 import javax.el.MethodInfo;
 import javax.el.MethodNotFoundException;
 import javax.el.PropertyNotFoundException;
+import javax.el.ValueReference;
 
 import de.odysseus.el.misc.LocalMessages;
 import de.odysseus.el.tree.Bindings;
@@ -31,17 +32,36 @@
 	protected final AstNode prefix;
 	protected final boolean lvalue;
 	protected final boolean strict; // allow null as property value?
+	protected final AstParameters params;
 	
 	public AstProperty(AstNode prefix, boolean lvalue, boolean strict) {
 		this.prefix = prefix;
 		this.lvalue = lvalue;
+		this.params = null;
 		this.strict = strict;
 	}
 
+	public AstProperty(AstNode prefix, AstParameters params) {
+		this.prefix = prefix;
+		this.lvalue = false;
+		this.params = params;
+		this.strict = true;
+	}
+
 	protected abstract Object getProperty(Bindings bindings, ELContext context) throws ELException;
 
+	public ValueReference getValueReference(Bindings bindings, ELContext context) {
+		if (params == null) {
+			return null;
+		}
+		return new ValueReference(prefix.eval(bindings, context), getProperty(bindings, context));
+	}
+	
 	@Override
 	public Object eval(Bindings bindings, ELContext context) {
+		if (params != null) { // JSR 245 MR2
+			return invoke(bindings, context, null, null, null);
+		}
 		Object base = prefix.eval(bindings, context);
 		if (base == null) {
 			return null;
@@ -139,6 +159,9 @@
 	}
 	
 	public MethodInfo getMethodInfo(Bindings bindings, ELContext context, Class<?> returnType, Class<?>[] paramTypes) {
+		if (params != null) {
+			return null;
+		}
 		Object base = prefix.eval(bindings, context);
 		if (base == null) {
 			throw new PropertyNotFoundException(LocalMessages.get("error.property.base.null", prefix));
@@ -162,6 +185,15 @@
 			throw new PropertyNotFoundException(LocalMessages.get("error.property.method.notfound", "null", base));
 		}
 		String name = bindings.convert(property, String.class);
+		if (params != null) { // JSR 245 MR2
+			Object[] args = params.eval(bindings, context);
+			context.setPropertyResolved(false);
+			Object result = context.getELResolver().invoke(context, base, name, paramTypes, args);
+			if (!context.isPropertyResolved()) {
+				throw new MethodNotFoundException(LocalMessages.get("error.property.method.notfound", name, base.getClass()));
+			}
+			return result;
+		}
 		Method method = findMethod(name, base.getClass(), returnType, paramTypes);
 		try {
 			return method.invoke(base, paramValues);
@@ -175,6 +207,6 @@
 	}
 
 	public AstNode getChild(int i) {
-		return i == 0 ? prefix : null;
+		return i == 0 ? prefix : params != null && i == getCardinality() - 1 ? params : null;
 	}
 }
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstRightValue.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstRightValue.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstRightValue.java	(working copy)
@@ -18,6 +18,7 @@
 import javax.el.ELContext;
 import javax.el.ELException;
 import javax.el.MethodInfo;
+import javax.el.ValueReference;
 
 import de.odysseus.el.misc.LocalMessages;
 import de.odysseus.el.tree.Bindings;
@@ -65,4 +66,8 @@
 	public final boolean isLeftValue() {
 		return false;
 	}
+	
+	public final ValueReference getValueReference(Bindings bindings, ELContext context) {
+		return null;
+	}
 }
Index: src/main/java/de/odysseus/el/tree/impl/ast/AstText.java
===================================================================
--- src/main/java/de/odysseus/el/tree/impl/ast/AstText.java	(revision 63)
+++ src/main/java/de/odysseus/el/tree/impl/ast/AstText.java	(working copy)
@@ -18,6 +18,7 @@
 import javax.el.ELContext;
 import javax.el.ELException;
 import javax.el.MethodInfo;
+import javax.el.ValueReference;
 
 import de.odysseus.el.misc.LocalMessages;
 import de.odysseus.el.tree.Bindings;
@@ -49,6 +50,10 @@
 		throw new ELException(LocalMessages.get("error.value.set.rvalue"));
 	}
 
+	public ValueReference getValueReference(Bindings bindings, ELContext context) {
+		return null;
+	}
+	
 	@Override 
 	public Object eval(Bindings bindings, ELContext context) {
 		return value;
Index: src/main/java/de/odysseus/el/util/SimpleResolver.java
===================================================================
--- src/main/java/de/odysseus/el/util/SimpleResolver.java	(revision 63)
+++ src/main/java/de/odysseus/el/util/SimpleResolver.java	(working copy)
@@ -144,5 +144,12 @@
 		} else {
 			delegate.setValue(context, base, property, value);
 		}
-	}		
+	}
+	
+	public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
+		if (resolve(context, base)) {
+			throw new NullPointerException("cannot invoke null");
+		}
+		return delegate.invoke(context, base, method, paramTypes, params);
+	}
 }
Index: src/main/java/javax/el/BeanELResolver.java
===================================================================
--- src/main/java/javax/el/BeanELResolver.java	(revision 63)
+++ src/main/java/javax/el/BeanELResolver.java	(working copy)
@@ -19,6 +19,7 @@
 import java.beans.IntrospectionException;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
+import java.lang.reflect.Array;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -123,6 +124,8 @@
 		}
 	}
 
+	private static final ExpressionFactory DEFAULT_FACTORY = ExpressionFactory.newInstance();
+
 	private final boolean readOnly;
 	private final ConcurrentHashMap<Class<?>, BeanProperties> cache;
 
@@ -186,13 +189,15 @@
 			try {
 				properties = Introspector.getBeanInfo(base.getClass()).getPropertyDescriptors();
 			} catch (IntrospectionException e) {
-				return Collections.<FeatureDescriptor>emptyList().iterator();
+				return Collections.<FeatureDescriptor> emptyList().iterator();
 			}
 			return new Iterator<FeatureDescriptor>() {
 				int next = 0;
-				public boolean hasNext() {					
+
+				public boolean hasNext() {
 					return properties != null && next < properties.length;
 				}
+
 				public FeatureDescriptor next() {
 					PropertyDescriptor property = properties[next++];
 					FeatureDescriptor feature = new FeatureDescriptor();
@@ -206,6 +211,7 @@
 					feature.setValue(RESOLVABLE_AT_DESIGN_TIME, true);
 					return feature;
 				}
+
 				public void remove() {
 					throw new UnsupportedOperationException("cannot remove");
 				}
@@ -397,6 +403,179 @@
 	}
 
 	/**
+	 * If the base object is not <code>null</code>, invoke the method, with the given parameters on
+	 * this bean. The return value from the method is returned.
+	 * 
+	 * <p>
+	 * If the base is not <code>null</code>, the <code>propertyResolved</code> property of the
+	 * <code>ELContext</code> object must be set to <code>true</code> by this resolver, before
+	 * returning. If this property is not <code>true</code> after this method is called, the caller
+	 * should ignore the return value.
+	 * </p>
+	 * 
+	 * <p>
+	 * The provided method object will first be coerced to a <code>String</code>. The methods in the
+	 * bean is then examined and an attempt will be made to select one for invocation. If no
+	 * suitable can be found, a <code>MethodNotFoundException</code> is thrown.
+	 * 
+	 * If the given paramTypes is not <code>null</code>, select the method with the given name and
+	 * parameter types.
+	 * 
+	 * Else select the method with the given name that has the same number of parameters. If there
+	 * are more than one such method, the method selection process is undefined.
+	 * 
+	 * Else select the method with the given name that takes a variable number of arguments.
+	 * 
+	 * Note the resolution for overloaded methods will likely be clarified in a future version of
+	 * the spec.
+	 * 
+	 * The provided parameters are coerced to the corresponding parameter types of the method, and
+	 * the method is then invoked.
+	 * 
+	 * @param context
+	 *            The context of this evaluation.
+	 * @param base
+	 *            The bean on which to invoke the method
+	 * @param method
+	 *            The simple name of the method to invoke. Will be coerced to a <code>String</code>.
+	 *            If method is "&lt;init&gt;"or "&lt;clinit&gt;" a MethodNotFoundException is
+	 *            thrown.
+	 * @param paramTypes
+	 *            An array of Class objects identifying the method's formal parameter types, in
+	 *            declared order. Use an empty array if the method has no parameters. Can be
+	 *            <code>null</code>, in which case the method's formal parameter types are assumed
+	 *            to be unknown.
+	 * @param params
+	 *            The parameters to pass to the method, or <code>null</code> if no parameters.
+	 * @return The result of the method invocation (<code>null</code> if the method has a
+	 *         <code>void</code> return type).
+	 * @throws MethodNotFoundException
+	 *             if no suitable method can be found.
+	 * @throws ELException
+	 *             if an exception was thrown while performing (base, method) resolution. The thrown
+	 *             exception must be included as the cause property of this exception, if available.
+	 *             If the exception thrown is an <code>InvocationTargetException</code>, extract its
+	 *             <code>cause</code> and pass it to the <code>ELException</code> constructor.
+	 * @since 2.1.3
+	 */
+	@Override
+	public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
+		if (context == null) {
+			throw new NullPointerException();
+		}
+		Object result = null;
+		if (isResolvable(base)) {
+			if (params == null) {
+				params = new Object[0];
+			}
+			String name = method.toString();
+			Method target = findMethod(base, name, paramTypes, params.length);
+			try {
+				result = target.invoke(base, coerceParams(getExpressionFactory(context), target, params));
+			} catch (InvocationTargetException e) {
+				throw new ELException(e.getCause());
+			} catch (IllegalAccessException e) {
+				throw new ELException(e);
+			}
+			context.setPropertyResolved(true);
+		}
+		return result;
+	};
+
+	private Method findMethod(Object base, String name, Class<?>[] types, int paramCount)
+			throws MethodNotFoundException {
+		if (types != null) {
+			try {
+				return base.getClass().getMethod(name, types);
+			} catch (NoSuchMethodException e) {
+				throw new MethodNotFoundException(e);
+			}
+		}
+		Method varArgsMethod = null;
+		for (Method method : base.getClass().getMethods()) {
+			if (method.getName().equals(name)) {
+				if (paramCount == method.getParameterTypes().length) {
+					return method;
+				} else if (method.isVarArgs() && paramCount >= method.getParameterTypes().length - 1) {
+					varArgsMethod = method;
+				}
+			}
+		}
+		if (varArgsMethod != null) {
+			return varArgsMethod;
+		}
+		throw new MethodNotFoundException("Cannot find matching method " + name + " on class " + base);
+	}
+
+	/**
+	 * Lookup an expression factory used to coerce method parameters in context under key
+	 * <code>"javax.el.ExpressionFactory"</code>.
+	 * If no expression factory can be found under that key, use a default instance created with
+	 * {@link ExpressionFactory#newInstance()}.
+	 * @param context
+	 *            The context of this evaluation.
+	 * @return expression factory instance
+	 */
+	private ExpressionFactory getExpressionFactory(ELContext context) {
+		Object obj = context.getContext(ExpressionFactory.class);
+		return obj instanceof ExpressionFactory ? (ExpressionFactory)obj : DEFAULT_FACTORY;
+	}
+	
+	private Object[] coerceParams(ExpressionFactory factory, Method method, Object[] params) {
+		Class<?>[] types = method.getParameterTypes();
+		Object[] args = new Object[types.length];
+		if (method.isVarArgs()) {
+			int varargIndex = types.length - 1;
+			if (params.length < varargIndex) {
+				throw new ELException("Bad argument count");
+			}
+			for (int i = 0; i < varargIndex; i++) {
+				coerceValue(args[i], i, factory, params[i], types[i]);
+			}
+			Class<?> varargType = types[varargIndex].getComponentType();
+			int length = params.length - varargIndex;
+			Object array = null;
+			if (length == 1) {
+				Object source = params[varargIndex];
+				if (source != null && source.getClass().isArray()) {
+					if (types[varargIndex].isInstance(source)) { // use source array as is
+						array = source;
+					} else { // coerce array elements
+						length = Array.getLength(source);
+						array = Array.newInstance(varargType, length);
+						for (int i = 0; i < length; i++) {
+							coerceValue(array, i, factory, Array.get(source, i), varargType);
+						}
+					}
+				} else { // single element array
+					array = Array.newInstance(varargType, 1);
+					coerceValue(array, 0, factory, source, varargType);
+				}
+			} else {
+				array = Array.newInstance(varargType, length);
+				for (int i = 0; i < length; i++) {
+					coerceValue(array, i, factory, params[varargIndex + i], varargType);
+				}
+			}
+			args[varargIndex] = array;
+		} else {
+			if (params.length != args.length) {
+				throw new ELException("Bad argument count");
+			}
+			for (int i = 0; i < args.length; i++) {
+				coerceValue(args, i, factory, params[i], types[i]);
+			}
+		}
+		return args;
+	}
+
+	private void coerceValue(Object array, int index, ExpressionFactory factory, Object value, Class<?> type) {
+		if (value != null || type.isPrimitive()) {
+			Array.set(array, index, factory.coerceToType(value, type));
+		}
+	}
+	
+	/**
 	 * Test whether the given base should be resolved by this ELResolver.
 	 * 
 	 * @param base
Index: src/main/java/javax/el/CompositeELResolver.java
===================================================================
--- src/main/java/javax/el/CompositeELResolver.java	(revision 63)
+++ src/main/java/javax/el/CompositeELResolver.java	(working copy)
@@ -125,7 +125,7 @@
 				}
 				return features;
 			}
-			
+
 			public boolean hasNext() {
 				return features().hasNext();
 			}
@@ -332,4 +332,73 @@
 			}
 		}
 	}
+
+	/**
+	 * Attemps to resolve and invoke the given <code>method</code> on the given <code>base</code>
+	 * object by querying all component resolvers.
+	 * 
+	 * <p>
+	 * If this resolver handles the given (base, method) pair, the <code>propertyResolved</code>
+	 * property of the <code>ELContext</code> object must be set to <code>true</code> by the
+	 * resolver, before returning. If this property is not <code>true</code> after this method is
+	 * called, the caller should ignore the return value.
+	 * </p>
+	 * 
+	 * <p>
+	 * First, <code>propertyResolved</code> is set to <code>false</code> on the provided
+	 * <code>ELContext</code>.
+	 * </p>
+	 * 
+	 * <p>
+	 * Next, for each component resolver in this composite:
+	 * <ol>
+	 * <li>The <code>invoke()</code> method is called, passing in the provided <code>context</code>,
+	 * <code>base</code>, <code>method</code>, <code>paramTypes</code>, and <code>params</code>.</li>
+	 * <li>If the <code>ELContext</code>'s <code>propertyResolved</code> flag is <code>false</code>
+	 * then iteration continues.</li>
+	 * <li>Otherwise, iteration stops and no more component resolvers are considered. The value
+	 * returned by <code>getValue()</code> is returned by this method.</li>
+	 * </ol>
+	 * </p>
+	 * 
+	 * <p>
+	 * If none of the component resolvers were able to perform this operation, the value
+	 * <code>null</code> is returned and the <code>propertyResolved</code> flag remains set to
+	 * <code>false</code>
+	 * </p>
+	 * 
+	 * <p>
+	 * Any exception thrown by component resolvers during the iteration is propagated to the caller
+	 * of this method.
+	 * </p>
+	 * 
+	 * @param context
+	 *            The context of this evaluation.
+	 * @param base
+	 *            The bean on which to invoke the method
+	 * @param method
+	 *            The simple name of the method to invoke. Will be coerced to a <code>String</code>.
+	 *            If method is "<init>"or "<clinit>" a NoSuchMethodException is raised.
+	 * @param paramTypes
+	 *            An array of Class objects identifying the method's formal parameter types, in
+	 *            declared order. Use an empty array if the method has no parameters. Can be
+	 *            <code>null</code>, in which case the method's formal parameter types are assumed
+	 *            to be unknown.
+	 * @param params
+	 *            The parameters to pass to the method, or <code>null</code> if no parameters.
+	 * @return The result of the method invocation (<code>null</code> if the method has a
+	 *         <code>void</code> return type).
+	 * @since 2.1.3
+	 */
+	@Override
+	public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
+		context.setPropertyResolved(false);
+		for (ELResolver resolver : resolvers) {
+			Object result = resolver.invoke(context, base, method, paramTypes, params);
+			if (context.isPropertyResolved()) {
+				return result;
+			}
+		}
+		return null;
+	}
 }
Index: src/main/java/javax/el/ELResolver.java
===================================================================
--- src/main/java/javax/el/ELResolver.java	(revision 63)
+++ src/main/java/javax/el/ELResolver.java	(working copy)
@@ -246,4 +246,48 @@
 	 *             available.
 	 */
 	public abstract void setValue(ELContext context, Object base, Object property, Object value);
+
+	/**
+	 * Attemps to resolve and invoke the given <code>method</code> on the given <code>base</code>
+	 * object.
+	 * 
+	 * <p>
+	 * If this resolver handles the given (base, method) pair, the <code>propertyResolved</code>
+	 * property of the <code>ELContext</code> object must be set to <code>true</code> by the
+	 * resolver, before returning. If this property is not <code>true</code> after this method is
+	 * called, the caller should ignore the return value.
+	 * </p>
+	 * 
+	 * <p>
+	 * A default implementation is provided that returns null so that existing classes that extend
+	 * ELResolver can continue to function.
+	 * </p>
+	 * 
+	 * @param context
+	 *            The context of this evaluation.
+	 * @param base
+	 *            The bean on which to invoke the method
+	 * @param method
+	 *            The simple name of the method to invoke. Will be coerced to a <code>String</code>.
+	 * @param paramTypes
+	 *            An array of Class objects identifying the method's formal parameter types, in
+	 *            declared order. Use an empty array if the method has no parameters. Can be
+	 *            <code>null</code>, in which case the method's formal parameter types are assumed
+	 *            to be unknown.
+	 * @param params
+	 *            The parameters to pass to the method, or <code>null</code> if no parameters.
+	 * @return The result of the method invocation (<code>null</code> if the method has a
+	 *         <code>void</code> return type).
+	 * @throws MethodNotFoundException
+	 *             if no suitable method can be found.
+	 * @throws ELException
+	 *             if an exception was thrown while performing (base, method) resolution. The thrown
+	 *             exception must be included as the cause property of this exception, if available.
+	 *             If the exception thrown is an <code>InvocationTargetException</code>, extract its
+	 *             <code>cause</code> and pass it to the <code>ELException</code> constructor.
+	 * @since 2.1.3
+	 */
+	public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
+		return null;
+	}
 }
Index: src/main/java/javax/el/ValueExpression.java
===================================================================
--- src/main/java/javax/el/ValueExpression.java	(revision 63)
+++ src/main/java/javax/el/ValueExpression.java	(working copy)
@@ -30,14 +30,16 @@
  * {@link #setValue(ELContext, Object)}, {@link #isReadOnly(ELContext)} and
  * {@link #getType(ELContext)} methods will evaluate the expression each time they are called. The
  * {@link ELResolver} in the ELContext is used to resolve the top-level variables and to determine
- * the behavior of the . and [] operators. For any of the four methods, the {@link
- * ELResolver#getValue(ELContext, Object, Object)} method is used to resolve all properties up to
- * but excluding the last one. This provides the base object. At the last resolution, the
- * ValueExpression will call the corresponding {@link ELResolver#getValue(ELContext, Object,
- * Object)}, {@link ELResolver#setValue(ELContext, Object, Object, Object)}, {@link
- * ELResolver#isReadOnly(ELContext, Object, Object)} or {@link ELResolver#getType(ELContext, Object,
- * Object)} method, depending on which was called on the ValueExpression. See the notes about
- * comparison, serialization and immutability in the {@link Expression} javadocs.
+ * the behavior of the . and [] operators. For any of the four methods, the
+ * {@link ELResolver#getValue(ELContext, Object, Object)} method is used to resolve all properties
+ * up to but excluding the last one. This provides the base object. At the last resolution, the
+ * ValueExpression will call the corresponding
+ * {@link ELResolver#getValue(ELContext, Object, Object)},
+ * {@link ELResolver#setValue(ELContext, Object, Object, Object)},
+ * {@link ELResolver#isReadOnly(ELContext, Object, Object)} or
+ * {@link ELResolver#getType(ELContext, Object, Object)} method, depending on which was called on
+ * the ValueExpression. See the notes about comparison, serialization and immutability in the
+ * {@link Expression} javadocs.
  * 
  * @see ELResolver
  * @see Expression
@@ -139,4 +141,21 @@
 	 *             available.
 	 */
 	public abstract void setValue(ELContext context, Object value);
+
+	/**
+	 * Returns a {@link ValueReference} for this expression instance.
+	 * 
+	 * @param context
+	 *            the context of this evaluation
+	 * @return the <code>ValueReference</code> for this <code>ValueExpression</code>, or
+	 *         <code>null</code> if this <code>ValueExpression</code> is not a reference to a base
+	 *         (null or non-null) and a property. If the base is null, and the property is a EL
+	 *         variable, return the <code>ValueReference</code> for the <code>ValueExpression</code>
+	 *         associated with this EL variable.
+	 * 
+	 * @since 2.1.3
+	 */
+	public ValueReference getValueReference(ELContext context) {
+		return null;
+	}
 }
Index: src/main/java/javax/el/ValueReference.java
===================================================================
--- src/main/java/javax/el/ValueReference.java	(revision 0)
+++ src/main/java/javax/el/ValueReference.java	(revision 0)
@@ -0,0 +1,28 @@
+package javax.el;
+
+import java.io.Serializable;
+
+/**
+ * This class encapsulates a base model object and one of its properties.
+ * 
+ * @since 2.1.3
+ */
+public class ValueReference implements Serializable {
+	private static final long serialVersionUID = 1L;
+
+	private Object base;
+	private Object property;
+
+	public ValueReference(Object base, Object property) {
+		this.base = base;
+		this.property = property;
+	}
+
+	public Object getBase() {
+		return base;
+	}
+
+	public Object getProperty() {
+		return property;
+	}
+}
\ No newline at end of file
Index: src/test/java/de/odysseus/el/TestCase.java
===================================================================
--- src/test/java/de/odysseus/el/TestCase.java	(revision 63)
+++ src/test/java/de/odysseus/el/TestCase.java	(working copy)
@@ -26,7 +26,7 @@
 import de.odysseus.el.tree.impl.Builder;
 
 public abstract class TestCase extends junit.framework.TestCase {
-	protected static final Builder BUILDER = new Builder();
+	protected static final Builder BUILDER = new Builder(Builder.Feature.METHODS);
 
 	protected static final Tree parse(String expression) {
 		return BUILDER.build(expression);
Index: src/test/java/de/odysseus/el/tree/impl/ast/AstBracketTest.java
===================================================================
--- src/test/java/de/odysseus/el/tree/impl/ast/AstBracketTest.java	(revision 63)
+++ src/test/java/de/odysseus/el/tree/impl/ast/AstBracketTest.java	(working copy)
@@ -85,6 +85,7 @@
 	public void testIsLeftValue() {
 		assertFalse(parseNode("${'foo'[bar]}").isLeftValue());
 		assertTrue(parseNode("${foo[bar]}").isLeftValue());
+		assertFalse(parseNode("${foo[bar]()}").isLeftValue());
 	}
 
 	public void testGetType() {
@@ -96,6 +97,7 @@
 		} else {
 			try { parseNode("${nullmap[null]}").getType(bindings, context); fail(); } catch (ELException e) {}
 		}
+		assertNull(parseNode("${base['foo']()}").getType(bindings, context));
 	}
 
 	public void testIsReadOnly() {
@@ -106,6 +108,7 @@
 		} else {
 			try { parseNode("${nullmap[null]}").isReadOnly(bindings, context); fail(); } catch (ELException e) {}
 		}
+		assertTrue(parseNode("${base['foo']()}").isReadOnly(bindings, context));
 	}
 
 	public void testSetValue() {
@@ -119,6 +122,7 @@
 		} else {
 			try { parseNode("${nullmap[null]}").setValue(bindings, context, "bar"); fail(); } catch (ELException e) {}
 		}
+		try { parseNode("${base['foo']()}").setValue(bindings, context, 0); fail(); } catch (ELException e) {}
 	}
 
 	public void testGetValue() {
@@ -129,11 +133,16 @@
 		} else {
 			assertNull(parseNode("${nullmap[null]}").getValue(bindings, context, null));
 		}
+		assertEquals("1", parseNode("${base['bar']()}").getValue(bindings, context, String.class));
+		assertEquals("3", parseNode("${base['bar'](3)}").getValue(bindings, context, String.class));
 	}
 	
 	public void testInvoke() {
 		assertEquals(1l, parseNode("${base['bar']}").invoke(bindings, context, long.class, new Class[0], null));
 		assertEquals(2l, parseNode("${base['bar']}").invoke(bindings, context, null, new Class[]{long.class}, new Object[]{2l}));
+
+		assertEquals(1l, parseNode("${base['bar']()}").invoke(bindings, context, null, null, new Object[]{999l}));
+		assertEquals(3l, parseNode("${base['bar'](3)}").invoke(bindings, context, null, new Class[]{long.class}, new Object[]{999l}));
 	}
 
 	public void testGetMethodInfo() {
@@ -155,5 +164,7 @@
 		try { info = parseNode("${base['bar']}").getMethodInfo(bindings, context, null, new Class[]{String.class}); fail(); } catch(ELException e) {}
 		// bad return type
 		try { info = parseNode("${base['bar']}").getMethodInfo(bindings, context, String.class, new Class[0]); fail(); } catch(ELException e) {}
+		
+		assertNull(parseNode("${base['bar']()}").getMethodInfo(bindings, context, null, new Class[]{long.class}));
 	}
 }
Index: src/test/java/de/odysseus/el/tree/impl/ast/AstDotTest.java
===================================================================
--- src/test/java/de/odysseus/el/tree/impl/ast/AstDotTest.java	(revision 63)
+++ src/test/java/de/odysseus/el/tree/impl/ast/AstDotTest.java	(working copy)
@@ -79,33 +79,43 @@
 	public void testIsLeftValue() {
 		assertFalse(parseNode("${'foo'.bar}").isLeftValue());
 		assertTrue(parseNode("${foo.bar}").isLeftValue());
+		assertFalse(parseNode("${foo.bar()}").isLeftValue());
 	}
 
 	public void testGetType() {
 		try { parseNode("${base.bad}").getType(bindings, context); fail(); } catch (ELException e) {}
 		assertEquals(long.class, parseNode("${base.foo}").getType(bindings, context));
 		assertNull(parseNode("${'base'.foo}").getType(bindings, context));
+		assertNull(parseNode("${base.foo()}").getType(bindings, context));
 	}
 
 	public void testIsReadOnly() {
 		assertFalse(parseNode("${base.foo}").isReadOnly(bindings, context));
 		assertTrue(parseNode("${'base'.foo}").isReadOnly(bindings, context));
+		assertTrue(parseNode("${base.foo()}").isReadOnly(bindings, context));
 	}
 
 	public void testSetValue() {
 		try { parseNode("${base.bad}").setValue(bindings, context, "good"); fail(); } catch (ELException e) {}
 		parseNode("${base.foo}").setValue(bindings, context, 2l);
 		assertEquals(2l, getFoo());
+		try { parseNode("${base.foo()}").setValue(bindings, context, 0); fail(); } catch (ELException e) {}
 	}
 
 	public void testGetValue() {
 		assertEquals(1l, parseNode("${base.foo}").getValue(bindings, context, null));
 		assertEquals("1", parseNode("${base.foo}").getValue(bindings, context, String.class));
+
+		assertEquals("1", parseNode("${base.bar()}").getValue(bindings, context, String.class));
+		assertEquals("3", parseNode("${base.bar(3)}").getValue(bindings, context, String.class));
 	}
 	
 	public void testInvoke() {
 		assertEquals(1l, parseNode("${base.bar}").invoke(bindings, context, long.class, new Class[0], null));
 		assertEquals(2l, parseNode("${base.bar}").invoke(bindings, context, null, new Class[]{long.class}, new Object[]{2l}));
+
+		assertEquals(1l, parseNode("${base.bar()}").invoke(bindings, context, null, null, new Object[]{999l}));
+		assertEquals(3l, parseNode("${base.bar(3)}").invoke(bindings, context, null, new Class[]{long.class}, new Object[]{999l}));
 	}
 
 	public void testGetMethodInfo() {
@@ -127,5 +137,7 @@
 		try { info = parseNode("${base.bar}").getMethodInfo(bindings, context, null, new Class[]{String.class}); fail(); } catch(ELException e) {}
 		// bad return type
 		try { info = parseNode("${base.bar}").getMethodInfo(bindings, context, String.class, new Class[0]); fail(); } catch(ELException e) {}
+		
+		assertNull(parseNode("${base.bar()}").getMethodInfo(bindings, context, null, new Class[]{long.class}));
 	}
 }
